module Lib
    ( run
    ) where

import Data.Char as C

-- run :: IO ()
-- run = print $
-- run = print $ take 8 $ runPhase 0 $ runPhase 0 linput

run = print $ take 8 $ drop (tb - tsecret) $ runPhase 0 linput

runPhase c signal =
  case c of
    100 -> signal
    _ -> runPhase (c+1) newSignal
    where newSignal = calc2 (0:signal) 0 <$> [tsecret..((length signal)+tsecret)]


calc2 signal acc n =
  case signal of
    [] -> acc' - ((div acc' 10) * 10)
          where acc' = abs acc
    _ -> calc2 sss (acc + new) n
  where
    new = calc ss n
    (ss, sss) = splitAt (n*4) signal

calc ss n = (sum x) - (sum y)
  where
    y = take n $ drop (3*n) ss
    x = take n $ drop n ss

linput :: [Int]
-- linput = C.digitToInt <$> tinput
linput = drop tsecret $ concat $ replicate 10000 $ C.digitToInt <$> ttinput

tinput = "12345678"
ttinput = "03036732577212944063491565474664"
tb = 0303673
tsecret = 0300000

secret = 5900000
b = 5978261
input = "59782619540402316074783022180346847593683757122943307667976220344797950034514416918778776585040527955353805734321825495534399127207245390950629733658814914072657145711801385002282630494752854444244301169223921275844497892361271504096167480707096198155369207586705067956112600088460634830206233130995298022405587358756907593027694240400890003211841796487770173357003673931768403098808243977129249867076581200289745279553289300165042557391962340424462139799923966162395369050372874851854914571896058891964384077773019120993386024960845623120768409036628948085303152029722788889436708810209513982988162590896085150414396795104755977641352501522955134675"
